import type { ConfigExtractor, ObjectString, ObjectStringArray } from './types';
import { existsSync, lstatSync, readdirSync, readFileSync } from 'node:fs';

import { resolve } from 'node:path/posix';
import consola from 'consola';

export abstract class CoreBase {
  protected readonly REGEX_FILE_IMPORT = /(\w+)\sfrom\s'([^'"]+)(?<=vue)/gi;
  protected readonly REGEX_AUTO_IMPORT_NAME =
    /export\sconst\s(?!Lazy)([a-z]+[^:])/gi;

  protected readonly REGEX_AUTO_IMPORT_FILE = /([^/]+\.vue)/gi;
  protected readonly REGEX_AUTO_IMPORT =
    /['"]([^'"]+)['"]:\s*typeof\s+import\(['"]([^'"]+\.vue)['"]\)/g;
  protected readonly REGEX_I18N_KEY =
    /\b(?:\$t|t)\(\s*["'`]([^"'`]+)["'`][\s\S]*\)/gi;

  protected readonly REGEX_TEMPLATE_COMPONENT = /<(\w+)/g;
  protected readonly REGEX_TEMPLATE_CONTENT =
    /<template>([\s\S]*?)<\/template>/g;

  protected config: ConfigExtractor = {
    AUTO_IMPORT_DECLARATION_NAME: 'components.d.ts',
    AUTO_IMPORT_DECLARATION_PATH: '',
    TSCONFIG_PATH: '',
    REPORT_FILE_TYPE: 'json',
    REPORT_NAME: 'i18n-report',
    ALLOW_EMPTY_FILES: true,
    REPORT_OUTPUT: './',
  };

  autoImports: ObjectString = {};

  foundedKeys: ObjectStringArray = {};
  rootDir = '';
  selectedPath = '';

  protected get autoImportPath() {
    const path =
      this.config.AUTO_IMPORT_DECLARATION_PATH ||
      `${this.rootDir}.nuxt/${this.config.AUTO_IMPORT_DECLARATION_NAME}`;
    if (existsSync(path)) return path;
    return undefined;
  }

  protected get tsconfigPath() {
    return this.config.TSCONFIG_PATH || `${this.rootDir}.nuxt/tsconfig.json`;
  }

  protected get inputIsFile() {
    return lstatSync(this.selectedPath).isFile();
  }

  // get alias from nuxt-tsconfig or custom tsconfig
  protected get importsAlias(): ObjectStringArray {
    const path = this.tsconfigPath;
    try {
      return (
        JSON.parse(
          readFileSync(path, 'utf-8')
            // hardcoded way to get correct json for parse
            .replace('// Generated by nuxi', ''),
        ).compilerOptions?.paths ?? {}
      );
    } catch {
      return {};
    }
  }

  protected log(...args: any[]) {
    consola.info('INFO:', ...args);
  }

  protected recursiveCheckDirectory(dir: string, files_: string[] = []) {
    const files = readdirSync(dir);
    for (const file of files) {
      const name = resolve(dir, file);
      if (lstatSync(name).isDirectory()) {
        this.recursiveCheckDirectory(name, files_);
      } else {
        files_.push(name);
      }
    }
    return files_;
  }
}
