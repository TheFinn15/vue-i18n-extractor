import type { ConfigExtractor, ObjectString, ObjectStringArray } from './types';
import { existsSync, readdirSync, readFileSync } from 'node:fs';

import process from 'node:process';
import path from 'upath';
import { isFile } from './utils';

export abstract class CoreBase {
  protected readonly REGEX_FILE_IMPORT = /(\w+)\sfrom\s'([^'"]+)(?<=vue)/gi;
  protected readonly REGEX_AUTO_IMPORT_NAME
    = /export\sconst\s(?!Lazy)([a-z]+[^:])/gi;

  protected readonly REGEX_AUTO_IMPORT_FILE = /([^/]+\.vue)/gi;
  protected readonly REGEX_AUTO_IMPORT
    = /['"]([^'"]+)['"]:\s*typeof\s+import\(['"]([^'"]+\.vue)['"]\)/g;

  protected readonly REGEX_I18N_KEY
    = /\b(?:\$t|t)\(\s*["'`]([^"'`]+)["'`][\s\S]*\)/gi;

  protected readonly REGEX_TEMPLATE_COMPONENT = /<(\w+)/g;
  protected readonly REGEX_TEMPLATE_CONTENT
    = /<template>([\s\S]*?)<\/template>/g;

  protected config: ConfigExtractor = {
    AUTO_IMPORT_DECLARATION_NAME: 'components.d.ts',
    AUTO_IMPORT_DECLARATION_PATH: '',
    TSCONFIG_PATH: '',
    REPORT_FILE_TYPE: 'json',
    REPORT_NAME: 'i18n-report',
    ALLOW_EMPTY_FILES: true,
    REPORT_OUTPUT: './',
    DEBUG_MODE: false,
  };

  autoImports: ObjectString = {};

  foundedKeys: ObjectStringArray = {};
  rootDir = '';
  selectedPath = '';

  protected get autoImportPath() {
    const path
      = this.config.AUTO_IMPORT_DECLARATION_PATH
      || `${this.rootDir}.nuxt/${this.config.AUTO_IMPORT_DECLARATION_NAME}`;
    if (existsSync(path))
      return path;
    return undefined;
  }

  protected get isDebug() {
    return this.config.DEBUG_MODE;
  }

  protected get tsconfigPath() {
    return this.config.TSCONFIG_PATH || `${this.rootDir}.nuxt/tsconfig.json`;
  }

  protected get isWindows() {
    return process.platform === 'win32';
  }

  protected get inputIsFile() {
    return isFile(this.selectedPath);
  }

  // get alias from nuxt-tsconfig or custom tsconfig
  protected get importsAlias(): ObjectStringArray {
    const path = this.tsconfigPath;
    try {
      return (
        JSON.parse(
          readFileSync(path, 'utf-8')
            // hardcoded way to get correct json for parse
            .replace('// Generated by nuxi', ''),
        ).compilerOptions?.paths ?? {}
      );
    }
    catch {
      return {};
    }
  }

  protected recursiveCheckDirectory(dir: string, files_: string[] = []) {
    const files = readdirSync(dir);
    for (const file of files) {
      const name = path.resolve(dir, file);
      if (!isFile(name)) {
        this.recursiveCheckDirectory(name, files_);
      }
      else {
        files_.push(name);
      }
    }
    return files_;
  }

  protected resolveAlias(importPath: string) {
    const root = this.config.TSCONFIG_PATH
      ? this.rootDir
      : `${this.rootDir}.nuxt/`;
    const aliases = this.importsAlias;
    const sorted = Object.keys(this.importsAlias).sort(
      (a, b) => b.length - a.length,
    );
    const fallBackPath = path.resolve(root, importPath);
    for (const alias of sorted) {
      const aliasWithoutStar = alias.replace('/*', '');

      if (importPath.startsWith(aliasWithoutStar)) {
        const aliasPath = aliases[alias][0].replace('/*', '');

        return path.resolve(
          root,
          aliasPath,
          `./${importPath.replace(aliasWithoutStar, '')}`,
        );
      }
    }

    return existsSync(fallBackPath) ? fallBackPath : undefined;
  }
}
