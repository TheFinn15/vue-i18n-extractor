import consola from "consola";
import rl from "readline";
import {
  existsSync,
  writeFileSync,
  readFileSync,
  readdirSync,
  createReadStream,
} from "node:fs";
import { dirname, relative, basename, resolve } from "path";

interface ConfigExtractor {
  AUTO_IMPORT_DECLARATION_NAME: string;
  AUTO_IMPORT_DECLARATION_PATH: string;
  // provide if you have alias for imports
  TSCONFIG_PATH: string;
}

abstract class ExtractorPrivateBase {
  protected readonly REGEX_FILE_IMPORT =
    /(\w+)\sfrom\s'(?<=['"])([^'"]+)(?<=vue)/gi;
  protected readonly REGEX_AUTO_IMPORT_NAME =
    /export\sconst\s(?!Lazy)([a-zA-Z]+[^:])/gi;
  protected readonly REGEX_AUTO_IMPORT_FILE = /([^\/]+\.vue)/gi;
  protected readonly REGEX_AUTO_IMPORT_PATH_FILE = /"([^"]+\.vue)"/gi;
  protected readonly REGEX_I18N_KEY = /t\(['"`]([^'"`]+)['"`]\)/gi;
  protected readonly config: ConfigExtractor = {
    AUTO_IMPORT_DECLARATION_NAME: "components.d.ts",
    AUTO_IMPORT_DECLARATION_PATH: "",
    TSCONFIG_PATH: "",
  };
  protected autoImports: Record<string, string> = {};

  foundedKeys: string[] = [];
  rootDir = "";
  selectedFile = "";
}

class Extractor extends ExtractorPrivateBase {
  constructor(filePath: string) {
    super();

    this.selectedFile = filePath;

    this.getProjectRoot();
    this.parseAutoImports();
    this.extract();
  }

  private get autoImportPath() {
    const path =
      this.config.AUTO_IMPORT_DECLARATION_PATH ||
      `${this.rootDir}.nuxt/${this.config.AUTO_IMPORT_DECLARATION_NAME}`;
    if (existsSync(path)) return path;
    return undefined;
  }

  private get tsconfigPath() {
    return this.config.TSCONFIG_PATH || `${this.rootDir}.nuxt/tsconfig.json`;
  }

  // get alias from nuxt-tsconfig or custom tsconfig
  private get importsAlias(): Record<string, string[]> {
    const path = this.tsconfigPath;
    try {
      return (
        JSON.parse(
          readFileSync(path, "utf-8")
            // hardcoded way to get correct json for parse
            .replace("// Generated by nuxi", "")
        ).compilerOptions?.paths ?? {}
      );
    } catch (_e) {
      return {};
    }
  }

  private log(...args: any[]) {
    consola.info("INFO:", ...args);
  }

  private useRegex(regex: RegExp, text: string) {
    regex.lastIndex = 0;
    return regex.exec(text) ?? [];
  }

  private getProjectRoot() {
    let projectRoot = "";
    let tempPath = dirname(this.selectedFile);
    while (!projectRoot.length) {
      const currentFolder = basename(tempPath);
      if (readdirSync(tempPath).includes("package.json"))
        projectRoot = tempPath;
      else tempPath = tempPath.slice(0, tempPath.lastIndexOf(currentFolder));
    }
    this.rootDir = projectRoot;
  }

  private async extract(
    imports: Record<string, string> = {},
    file = this.selectedFile
  ) {
    const fileImports = imports;
    const stream = createReadStream(file);
    const rls = rl.createInterface({
      input: stream,
      crlfDelay: Infinity,
    });
    let countLines = 0;
    let countIncorrectImport = 0;

    for await (const line of rls) {
      this.REGEX_FILE_IMPORT.lastIndex = 0;
      this.REGEX_I18N_KEY.lastIndex = 0;
      const [_, name, path] = this.useRegex(this.REGEX_FILE_IMPORT, line);
      const [__, translationKey] = this.useRegex(this.REGEX_I18N_KEY, line);

      if (name && path) fileImports[name] = path;
      else countIncorrectImport += 1;
      if (translationKey) this.foundedKeys.push(translationKey);

      countLines += 1;
    }

    // leave recursive
    if (countLines === countIncorrectImport) {
      this.reportKeys();
      return;
    }

    Object.entries(fileImports).forEach(([_name, compPath]) => {
      this.extract(fileImports, this.resolveAlias(compPath));
    });
  }

  private reportKeys() {
    writeFileSync("keys.csv", this.foundedKeys.join("\n"));
  }

  private async parseAutoImports() {
    if (!this.autoImportPath) {
      this.log("Auto-Imported Components not found.");
      return;
    }
    const stream = createReadStream(this.autoImportPath);
    const rls = rl.createInterface({
      input: stream,
      crlfDelay: Infinity,
    });

    for await (const line of rls) {
      const [match] = this.REGEX_AUTO_IMPORT_PATH_FILE.exec(line) ?? [];

      if (match && !line.includes("Lazy")) {
        const componentName = line.split(" ")[2].replace(":", "");
        // REGEX_IMPORT_NAME.exec(line) ?? [];

        // remove duplicates by file path
        if (
          componentName &&
          Object.values(this.autoImports).every((v) => v !== match)
        ) {
          this.autoImports[componentName] = match;
        }
      }
    }
  }

  async delay(ms: number) {
    await new Promise((resolve) => setTimeout(resolve, ms));
  }

  resolveAlias(importPath: string) {
    const aliases = this.importsAlias;
    const sorted = Object.keys(this.importsAlias).sort(
      (a, b) => b.length - a.length
    );
    for (const alias of sorted) {
      const aliasWithoutStar = alias.replace("/*", "");

      if (importPath.startsWith(aliasWithoutStar)) {
        const aliasPath = aliases[alias][0].replace("/*", "");
        const root = this.config.TSCONFIG_PATH
          ? this.rootDir
          : `${this.rootDir}.nuxt/`;

        return resolve(
          root,
          aliasPath,
          `./${importPath.replace(aliasWithoutStar, "")}`
        );
      }
    }
    return importPath;
  }
}

const ROOT_FILE =
  "/Users/thefinn/Desktop/WTFCODE/jovo-mvp_frontend/apps/web/pages/index.vue";

const extr = new Extractor(ROOT_FILE);
// consola.info(extr.resolveAlias("@components/standard/button/CustomButton.vue"));
// console.log(
//   JSON.parse(
//     readFileSync(
//       "/Users/thefinn/Desktop/WTFCODE/jovo-mvp_frontend/apps/web/.nuxt/tsconfig.json",
//       "utf-8"
//     ).replace("// Generated by nuxi", "")
//   )
// );
// JSON.parse(readFileSync("package.json", "utf8")).name;
