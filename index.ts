import {
  createReadStream,
  existsSync,
  readdirSync,
  readFileSync,
  writeFileSync,
} from "node:fs";
import { basename, dirname, resolve } from "node:path";
import rl from "node:readline";
import consola from "consola";
import { createObjectCsvWriter } from "csv-writer";

type ReportType = "csv" | "json";

interface ConfigExtractor {
  AUTO_IMPORT_DECLARATION_NAME: string;
  AUTO_IMPORT_DECLARATION_PATH: string;
  // provide if you have alias for imports
  TSCONFIG_PATH: string;

  REPORT_FILE_TYPE: ReportType;
  REPORT_NAME: string;
}

abstract class ExtractorPrivateBase {
  protected readonly REGEX_FILE_IMPORT = /(\w+)\sfrom\s'([^'"]+)(?<=vue)/gi;
  protected readonly REGEX_AUTO_IMPORT_NAME =
    /export\sconst\s(?!Lazy)([a-z]+[^:])/gi;
  protected readonly REGEX_AUTO_IMPORT_FILE = /([^/]+\.vue)/gi;
  protected readonly REGEX_AUTO_IMPORT_PATH_FILE = /"([^"]+\.vue)"/gi;
  protected readonly REGEX_I18N_KEY =
    /\b(?:\$t|t)\(\s*["'`]([^"'`]+)["'`]\s*\)/gi;
  protected readonly REGEX_TEMPLATE_COMPONENT = /(?:<)(\w+)/gi;

  protected readonly config: ConfigExtractor = {
    AUTO_IMPORT_DECLARATION_NAME: "components.d.ts",
    AUTO_IMPORT_DECLARATION_PATH: "",
    TSCONFIG_PATH: "",
    REPORT_FILE_TYPE: "json",
    REPORT_NAME: "i18n-report",
  };

  protected autoImports: Record<string, string> = {};

  foundedKeys: Record<string, string[]> = {};
  rootDir = "";
  selectedFile = "";
}

class Extractor extends ExtractorPrivateBase {
  constructor(filePath: string) {
    super();

    this.selectedFile = filePath;

    this.getProjectRoot();
    this.parseAutoImports();

    (async () => {
      await this.delay(200);
      this.extract();
    })();
  }

  private get autoImportPath() {
    const path =
      this.config.AUTO_IMPORT_DECLARATION_PATH ||
      `${this.rootDir}.nuxt/${this.config.AUTO_IMPORT_DECLARATION_NAME}`;
    if (existsSync(path)) return path;
    return undefined;
  }

  private get tsconfigPath() {
    return this.config.TSCONFIG_PATH || `${this.rootDir}.nuxt/tsconfig.json`;
  }

  // get alias from nuxt-tsconfig or custom tsconfig
  private get importsAlias(): Record<string, string[]> {
    const path = this.tsconfigPath;
    try {
      return (
        JSON.parse(
          readFileSync(path, "utf-8")
            // hardcoded way to get correct json for parse
            .replace("// Generated by nuxi", "")
        ).compilerOptions?.paths ?? {}
      );
    } catch {
      return {};
    }
  }

  private log(...args: any[]) {
    consola.info("INFO:", ...args);
  }

  private useRegex(regex: RegExp, text: string) {
    regex.lastIndex = 0;
    return regex.exec(text) ?? [];
  }

  private getProjectRoot() {
    let projectRoot = "";
    let tempPath = dirname(this.selectedFile);
    while (!projectRoot.length) {
      const currentFolder = basename(tempPath);
      if (readdirSync(tempPath).includes("package.json"))
        projectRoot = tempPath;
      else tempPath = tempPath.slice(0, tempPath.lastIndexOf(currentFolder));
    }
    this.rootDir = projectRoot;
  }

  private async extract(
    imports: Record<string, string> = {},
    file = this.selectedFile
  ) {
    const currentFileName = basename(file);
    const fileImports = imports;
    const stream = createReadStream(file);
    const rls = rl.createInterface({
      input: stream,
      crlfDelay: Infinity,
    });
    let countLines = 0;
    let countIncorrectImport = 0;

    this.foundedKeys[currentFileName] = [];

    for await (const line of rls) {
      const [_g, componentName] = this.useRegex(
        this.REGEX_TEMPLATE_COMPONENT,
        line
      );
      const [_, name, path] = this.useRegex(this.REGEX_FILE_IMPORT, line);
      const [__, translationKey] = this.useRegex(this.REGEX_I18N_KEY, line);

      if (componentName in this.autoImports) {
        fileImports[componentName] = this.autoImports[componentName];
      } else if (name && path) {
        fileImports[name] = path;
      } else {
        countIncorrectImport += 1;
      }
      if (translationKey) {
        this.foundedKeys[currentFileName].push(translationKey);
      }

      countLines += 1;
    }

    if (countLines === countIncorrectImport) {
      this.reportKeys();
      process.exit();
    }

    Object.entries(fileImports).forEach(([name, compPath]) => {
      if (name in this.foundedKeys) return;
      this.extract(fileImports, this.resolveAlias(compPath));
    });
  }

  private reportKeys() {
    if (!Object.values(this.foundedKeys).flat().length) {
      consola.error(
        `Translation keys not found in or subpaths: ${this.selectedFile}`
      );
      return;
    }

    const fileType = this.config.REPORT_FILE_TYPE;
    const reportName = this.config.REPORT_NAME;
    const filePath = `${reportName}.${fileType}`;

    const csvHeaders = [
      {
        id: "name",
        title: "Component",
      },
      {
        id: "key",
        title: "Variable",
      },
    ];

    switch (fileType) {
      case "csv":
        createObjectCsvWriter({
          header: csvHeaders,
          path: filePath,
        }).writeRecords(
          Object.entries(this.foundedKeys).flatMap(([key, arr]) => {
            return arr.map((i) => ({ name: key, key: i }));
          })
        );
        break;
      case "json":
        writeFileSync(filePath, JSON.stringify(this.foundedKeys));
        break;
    }

    consola.success(`Translation keys is wrote in: ./${filePath}`);
  }

  private async parseAutoImports() {
    if (!this.autoImportPath) {
      this.log("Auto-Imported Components not found.");
      return;
    }
    const stream = createReadStream(this.autoImportPath);
    const rls = rl.createInterface({
      input: stream,
      crlfDelay: Infinity,
    });

    for await (const line of rls) {
      const [match] = this.REGEX_AUTO_IMPORT_PATH_FILE.exec(line) ?? [];

      if (match && !line.includes("Lazy")) {
        const componentName = line.split(" ")[2].replace(":", "");
        // REGEX_IMPORT_NAME.exec(line) ?? [];

        // remove duplicates by file path
        if (
          componentName &&
          Object.values(this.autoImports).every((v) => v !== match)
        ) {
          this.autoImports[componentName] = match.replaceAll(/"|'|`/g, "");
        }
      }
    }
  }

  async delay(ms: number) {
    await new Promise((resolve) => setTimeout(resolve, ms));
  }

  private resolveAlias(importPath: string) {
    const root = this.config.TSCONFIG_PATH
      ? this.rootDir
      : `${this.rootDir}.nuxt/`;
    const aliases = this.importsAlias;
    const sorted = Object.keys(this.importsAlias).sort(
      (a, b) => b.length - a.length
    );
    for (const alias of sorted) {
      const aliasWithoutStar = alias.replace("/*", "");

      if (importPath.startsWith(aliasWithoutStar)) {
        const aliasPath = aliases[alias][0].replace("/*", "");

        return resolve(
          root,
          aliasPath,
          `./${importPath.replace(aliasWithoutStar, "")}`
        );
      }
    }
    return resolve(root, importPath);
  }
}

const ROOT_FILE =
  "/Users/thefinn/Desktop/WTFCODE/jovo-mvp_frontend/apps/web/pages/index.vue";

new Extractor(ROOT_FILE);
